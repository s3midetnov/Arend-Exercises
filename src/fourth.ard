\import first

\func Leibniz {A : \Type} {a a' : A}
              (f : \Pi (P : A -> \Type) -> \Sigma (P a -> P a') (P a' -> P a)) : a = a'
  => (f (\lam x => a = x)).1 idp

\func transport {A : \Type} (B : A -> \Type) {a a' : A} (p : a = a') (b : B a) : B a'
  => coe (\lam i => B (p @ i)) b right

-- symmetry
\func inv {A : \Type} {a a' : A} (p : a = a') : a' = a
  => transport (\lam x => x = a) p idp

-- transitivity
\func trans {A : \Type} {a a' a'' : A} (p : a = a') (q : a' = a'') : a = a''
  => transport (\lam x => a = x) q p

-- congruence
\func pmap {A B : \Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a'
  => transport (\lam x => f a = f x) p idp

{-Exercise 1: Define congruence for functions with two arguments via transport.
 It is allowed to use any functions defined via transport.
 Clarification: if f : A -> B -> C, a = a', b = b', then f a b = f a' b'
 -}

\func change {A B C : \Type} (f : A -> B -> C) : B -> A -> C =>
  \lam b a => f a b

\func congruence2 {A B C : \Type} (f : A -> B -> C) {a a' : A} {b b' : B} (p : a = a') (q : b = b'): f a b = f a' b'
  => trans (pmap (f a) q) (pmap ((change f) b') p)


{-Exercise 2: Prove that transport can be defined via pmap and repl and vice versa.
 The function repl says that if two types are equal then there exists a function between them.-}

{-path (f : I -> A) : f left = f right

  path f @ i ==> f i -- beta-equivalence
--path (\lam i => p @ i) ==> p -- eta-equivalence-}

\func idp {A : \Type} {a : A} : a = a => path (\lam _ => a)

{-Exercise 3: Prove that left = right without using transport or coe.-}

\func id (A : \Type) (a : A) => a
\func left=right : left = right => path (id I)

{-Exercise 4: Prove that a = {A} a’ and b = {B} b’ implies (a,b) = {\Sigma A B} (a’,b’) without using transport.-}

--\func exc4 {A B : \Type} {a a' : A} {b b' : B} (p : a = {A} a') (q : b = {B} b') : (a,b) = {\Sigma A B} (a’,b’)

{-Exercise 5: Prove that p = {\Sigma (x : A) (B x)} p’ implies p.1 = {A} p’.1 without using transport.-}

\func funExt {A : \Type} (B : A -> \Type) {f g : \Pi (a : A) -> B a}
             (p : \Pi (a : A) -> f a = g a) : f = g
  => path (\lam i => \lam a => p a @ i)

{-Exercise 6: Prove that (\lam x => not (not x)) = (\lam x => x)-}


-- Dependent eliminator for Nat (induction).
\func Nat-elim (P : Nat -> \Type)
               (z : P zero)
               (s : \Pi (n : Nat) -> P n -> P (suc n))
               (x : Nat) : P x \elim x
  | zero => z
  | suc n => s n (Nat-elim P z s n)

-- Non-dependent eliminator for Nat (recursion).
\func Nat-rec (P : \Type)
              (z : P)
              (s : Nat -> P -> P)
              (x : Nat) : P \elim x
  | zero => z
  | suc n => s n (Nat-rec P z s n)

-- Dependent eliminator for Bool (recursor for Bool is just 'if').
\func Bool-elim (P : Bool -> \Type)
                (t : P true)
                (f : P false)
                (x : Bool) : P x \elim x
  | true => t
  | false => f


{-Exercise 7: Define factorial via Nat-rec (i.e., without recursion and pattern matching).-}
\func one : Nat => suc zero

\func n! (n : Nat) : Nat => Nat-rec Nat one (\lam m x => x * suc m) n

{-Exercise 8: Prove associativity of Nat.+ via Nat-elim (i.e., without recursion and pattern matching).-}



