\import fifth
\import first
\import fourth
\import second

{- Exercise 1: Implement any sorting algorithm using
 \case for pattern matching on the result of comparison of elements of a list.-}
\func filter {A : \Type} (p : A -> Bool) (xs : List A) : List A \elim xs
  | nil => nil
  | cons x xs => \case p x \with {
    | true => cons x (filter p xs)
    | false => filter p xs
  }

\func insert-right-spot (x : Nat) (xs : List Nat) : List Nat \elim xs
  | nil => cons x nil
  | cons y ys => \case y < x \with {
    | true => cons y (insert-right-spot x ys)
    | false =>  cons x (cons y ys)
  }

\func insertSort (a : List Nat) : List Nat \elim a
  | nil => nil
  | cons x as => insert-right-spot x (insertSort as)
\data Empty

\func absurd {A : \Type} (e : Empty) : A

\data Unit | unit

\func \infix 4 <= (x y : Nat) : \Type
  | 0, _ => Unit
  | suc _, 0 => Empty
  | suc x, suc y => x <= y

\func length {A : \Type} (xs : List A) : Nat
  | nil => 0
  | cons _ xs => suc (length xs)

-- auxiliary helper lemma
\func <=-helper {x y : Nat} (p : x <= y) : x <= suc y \elim x, y
  | 0, _ => unit
  | suc x, 0 => absurd p
  | suc x, suc y => <=-helper p

\func filter-lem {A : \Type} (p : A -> Bool) (xs : List A) : length (filter p xs) <= length xs \elim xs
  | nil => unit
  | cons x xs => \case p x \as b \return length (\case b \with { | true => cons x (filter p xs) | false => filter p xs }) <= suc (length xs) \with {
    | true => filter-lem p xs
    | false => <=-helper (filter-lem p xs)
  }
{-Exercise 2: Define filter via if not using \case. Prove the lemma filter-lem for this version of filter.-}

\func filter' {A : \Type} (p : A -> Bool) (xs : List A) : List A \elim xs
  | nil => nil
  | cons x xs => if (p x) (cons x (filter p xs)) (filter p xs)

--\func filter-lem' {A : \Type} (p : A -> Bool) (xs : List A) : length (filter p xs) <= length xs \elim xs
--  | nil => unit
--  | cons x xs => if (p x)

\func foo' {A : \Type} (p : A -> Bool) (a : A) : p a = not (not (p a)) =>
  helper (p a)
  \where
    \func helper (b : Bool) : b = not (not b) \elim b
      | true => idp
      | false => idp



{-Exercise 3: Prove that, for every function f : Bool -> Bool and every x : Bool, it is true that f (f (f x)) = f x-}

\func three-applic' (f : Bool -> Bool) (q : f true = false): f (f (f true)) = f true =>
  \case (f false) \as b', idp : (b' = f false) \return f (f (f true)) = f true \with {
    | true, p => f (f (f true)) ==< pmap (\lam x => f (f x)) q >==
                f (f false) ==< pmap f (inv p) >== f true
    | false, p => f (f (f true)) ==< pmap (\lam x => f (f x)) q >==
                f (f false) ==< pmap f (inv p) >== f true
  }


\func three-applic (f : Bool -> Bool) (x : Bool) : f( f (f x)) = f x
   =>
     \case (f false) \as b, (f true) \as b', idp : (b = f false), idp : (b' = f true) \with{
    | false, false, p, p1 => {?}
    | false, true, p, p1 => {?}
    | true, false, p, p1 => {?}
    | true, true, p, p1 => {?}
  }



{-Exercise 4: Define the view, which represents a natural number as a pair of the quotient
and the remainder of division by a positive m. Implement the division function.-}


\data modView {m : Nat} (n : Nat)
  | repr (q r : Nat) (_ : T (r < m)) (_ : T(0 < m)) (n = q * m + r)

\func to-mod {m : Nat} (n : Nat) : modView {m} n


{-Exercise 5: Prove that the predicate ‘isEven’ is decidable.-}

\data Decide (A : \Type)
  | yes A
  | no (A -> Empty)

\data Parity (n : Nat)
  | even (k : Nat) (p : n = 2 * k)
  | odd (k : Nat) (p : n = 2 * k + 1)

\func DecPred {A : \Type} (P : A -> \Type) => \Pi (a : A) -> Decide (P a)

\func decidEven : DecPred (even)